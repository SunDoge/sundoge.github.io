<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用 Hexo 搭建个人博客</title>
    <url>/2019/09/14/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="安装Node-js和Hexo"><a href="#安装Node-js和Hexo" class="headerlink" title="安装Node.js和Hexo"></a>安装 Node.js 和 Hexo</h2><p>参照 Hexo 官网教程 <a href="https://hexo.io/docs/#Install-Node-js">https://hexo.io/docs/#Install-Node-js</a></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</span><br><span class="line">nvm install stable</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></tbody></table></figure>
<h2 id="创建你的博客"><a href="#创建你的博客" class="headerlink" title="创建你的博客"></a>创建你的博客</h2><p>参照 <a href="https://hexo.io/docs/setup">https://hexo.io/docs/setup</a></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo init sundoge.github.io</span><br></pre></td></tr></tbody></table></figure>
<p>我使用的 <code>hexo-cli</code> 版本为 <code>2.0.0</code> ，会自动拉取默认主题 <code>landscape</code> 。后面将引入 <a href="https://github.com/theme-next/hexo-theme-next">hexo-theme-next</a> 。</p>
<h2 id="使用Git管理你的博客"><a href="#使用Git管理你的博客" class="headerlink" title="使用Git管理你的博客"></a>使用 Git 管理你的博客</h2><p>Hexo 的设计有个矛盾的地方，theme 有自己的 config 文件，而且不会 merge 到顶层的 config，导致你很难用 git 管理你的 theme。如果你按照 theme-next 的官方文档 install，就相当于在 git 仓库里面创建另 git 仓库，git 是没法管理到仓库里面的仓库的。但是如果单纯使用 git submodule，修改 theme 里面的_config.yml 也是没法用 git 管理的。所以一个折中的方案是，先 fork 一份你要的主题，比如 <a href="https://github.com/SunDoge/hexo-theme-next">SunDoge/hexo-theme-next</a> ，然后 add submodule</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git submodule add git@github.com:SunDoge/hexo-theme-next.git themes/next</span><br></pre></td></tr></tbody></table></figure>
<p>这样 theme 和博客都能被管理到。如果需要更新 theme，只需要运行</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/5828324/update-git-submodule-to-latest-commit-on-origin">https://stackoverflow.com/questions/5828324/update-git-submodule-to-latest-commit-on-origin</a></p>
</blockquote>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git submodule foreach git pull origin master</span><br></pre></td></tr></tbody></table></figure>
<p>这个命令会更新所有的 submodule。</p>
<h2 id="使用theme-next"><a href="#使用theme-next" class="headerlink" title="使用theme-next"></a>使用 theme-next</h2><p>修改顶层<code>_config.yml</code></p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="comment"># theme: landscape</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></tbody></table></figure>
<p>修改 theme 里面的_config.yml</p>
<blockquote>
<p> themes/next/_config.yml</p>
</blockquote>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="开启math支持"><a href="#开启math支持" class="headerlink" title="开启math支持"></a>开启 math 支持</h3><blockquote>
<p><a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/MATH.md">https://github.com/theme-next/hexo-theme-next/blob/master/docs/MATH.md</a></p>
</blockquote>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Math Formulas Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in Front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line">    <span class="attr">mhchem:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) required for full Katex support.</span></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>
<p>我暂时使用 mathjax，如果实在太慢，后面再换成 katex。这里还需要替换默认的 render。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-pandoc --save # or hexo-renderer-kramed</span><br></pre></td></tr></tbody></table></figure>
<p>这里不用 kramed 的原因是它最后一次更新在 2017 年。还需要安装 pandoc</p>
<blockquote>
<p><a href="https://github.com/jgm/pandoc/blob/master/INSTALL.md">https://github.com/jgm/pandoc/blob/master/INSTALL.md</a></p>
</blockquote>
<p>安装 pandoc 这点让我很不满意，使用 Hexo 已经要安装很多东西了（node_modules），为了 mathjax 还要整个 pandoc。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><blockquote>
<p><a href="https://hexo.io/docs/deployment.html#Git">https://hexo.io/docs/deployment.html#Git</a></p>
</blockquote>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">git@github.com:SunDoge/sundoge.github.io.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">published</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后在 github 上新建一个 branch 名为 published</p>
<blockquote>
<p><a href="https://help.github.com/en/articles/creating-and-deleting-branches-within-your-repository">https://help.github.com/en/articles/creating-and-deleting-branches-within-your-repository</a></p>
</blockquote>
<p>并把它设为 default branch。然后执行</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></tbody></table></figure>
<p>编译好的文件会推送的 published 分支。</p>
<h2 id="为什么使用Hexo"><a href="#为什么使用Hexo" class="headerlink" title="为什么使用Hexo"></a>为什么使用 Hexo</h2><p>Hugo 虽然性能好，但是大部分主题年久失修，而且质量都不高，从 jekyll 和 hexo 移植的主题也大多有问题，缺少原有的部分功能。最后没办法，还是要用前端写的工具。</p>
<p>为了方便以后的写作，我计划使用 Rust 开发一个 hexo-cli 的子集，只支持 theme-next 的正确编译🕊🕊🕊​。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Hyper-V 上安装 manjaro</title>
    <url>/2019/09/15/%E5%9C%A8Hyper-V%E4%B8%8A%E5%AE%89%E8%A3%85manjaro/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://forum.manjaro.org/t/how-to-run-manjaro-on-windows-10-hyper-v-gen2/54092/20">https://forum.manjaro.org/t/how-to-run-manjaro-on-windows-10-hyper-v-gen2/54092/20</a></p>
</blockquote>
<p><img src="https://i.loli.net/2019/09/15/PFraGJk26T1WjVC.png" alt="xrdp"></p>
<p><a href="https://forum.manjaro.org/t/installing-manjaro-in-hyper-v-with-enhanced-session-support/79394">https://forum.manjaro.org/t/installing-manjaro-in-hyper-v-with-enhanced-session-support/79394</a></p>
]]></content>
      <tags>
        <tag>Manjaro</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>写作方向调整</title>
    <url>/2020/07/29/%E5%86%99%E4%BD%9C%E6%96%B9%E5%90%91%E8%B0%83%E6%95%B4/</url>
    <content><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>此次更新了 post 的命名格式。</p>
<h2 id="方向调整"><a href="#方向调整" class="headerlink" title="方向调整"></a>方向调整</h2><p>赵神钦定，这个博客以后只写赵神不会的东西。</p>
]]></content>
      <tags>
        <tag>Announcement</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 theme_config 管理你的 Hexo theme</title>
    <url>/2020/07/31/%E4%BD%BF%E7%94%A8theme-config%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84Hexo-theme/</url>
    <content><![CDATA[<p>自 Hexo 2.8.2 之后 <a href="https://hexo.io/docs/configuration">[1]</a>，Hexo 支持使用 <code>theme_config</code> 来配置 theme。在这之前，如果我们想要使用 git 来更新我们 theme，同时又想用 git 管理 theme 的 config，我所知道的唯一一个办法，就是 fork 一份 theme，修改其中的<code>_config.yml</code>，再用 <code>git submodule</code> 将 fork 的 theme 引入博客仓库中。这个过程比较繁琐。</p>
<p>现在，我们可以利用博客仓库下的<code>_config.yml</code> 来覆盖 theme 仓库下的 config。以我使用的 NexT 为例，默认的 Muse scheme 并不和我意，我希望将其修改成 Mist scheme，只需要添加几行配置：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">Mist</span></span><br></pre></td></tr></tbody></table></figure>
<p>Hexo 5.0.0 之后 <a href="https://hexo.io/docs/configuration">[1]</a>，我们还可以为每个 theme 创建一个单独的 config 文件来进行管理，文件命名规则为<code>_config.[theme].yml</code>。还是以 NexT 为例，创建<code>_config.next.yml</code>，修改内容为：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br></pre></td></tr></tbody></table></figure>
<p>theme 就配置好了。</p>
<p>很奇怪的一点是，目前很多关于 theme 的资料都没有提到 Hexo 已经支持覆盖 theme config，导致我使用了很长一段时间的 Hexo 3.9，却还是在用 fork+submodule 的方法来管理 theme。</p>
<p>下次我将尝试使用 github action 来自动 deploy 我的博客。</p>
<hr>
<p>2020-07-31 Update</p>
<p>Hexo 5.0.0 支持使用 npm 配置 theme 了。以后不需要手动管理版本，只需要</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">npm i hexo-theme-next --save</span><br></pre></td></tr></tbody></table></figure>
<p>目前通过 npm 安装的主题在执行 hexo clean 时会报错，是 Hexo 的已知问题，将在下个版本修复。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow Datasets: The Bad Parts</title>
    <url>/2020/08/02/TensorFlow-Datasets-The-Bad-Parts/</url>
    <content><![CDATA[<p>本文是 <a href="https://determined.ai/blog/tf-dataset-the-bad-parts/">https://determined.ai/blog/tf-dataset-the-bad-parts/</a> 的译文。我在尝试用 TensorFlow 参照 PyTorch 代码复现一些模型的时候也产生了同样的想法。本文仅供个人研究使用。</p>
<hr>
<p><strong>TLDR</strong>: TensorFlow 的 <code>tf.data</code> API 是一个常用的将数据加载进深度模型的方法。虽然 <code>tf.data</code> 有很多强大的功能，但是它是围绕顺序读取数据集设计的。这个设计导致它无法高效实现一些功能：shuffle 大数据集，分布式训练时对数据进行分片，实现容错训练（fault-tolerant training）。我们认为，在构建深度学习数据读取 API 时，随机访问应该是需要考虑的关键因素。</p>
<p>在构建端到端的企业深度学习平台时，工程团队可能会遇到<a href="https://determined.ai/blog/building-an-enterprise-deep-learning-platform/">许多陷阱</a>。最常见的问题之一涉及数据加载。训练期间的数据加载常常被忽略，但是它可能对吞吐量产生巨大影响。机器学习框架提供了一些抽象，试图让数据加载变得简单直接。但是，在看似简单接口背后可能隐藏了一些令人惊讶的问题。在这篇文章中，我们将带你了解一个常见的数据加载 API：<a href="https://www.tensorflow.org/api_docs/python/tf/data/Dataset">TensorFlow Datasets</a>。</p>
<p><img src="https://i.loli.net/2020/08/02/eKtHoD4mk1CyPsr.png" alt="image.png"></p>
<h2 id="Data-Loader-Patterns"><a href="#Data-Loader-Patterns" class="headerlink" title="Data Loader Patterns"></a>Data Loader Patterns</h2><p>数据加载接口可以使用两种基本模式，<strong>随机访问（random access）</strong>和<strong>顺序访问（sequential access）</strong>。</p>
<h3 id="Random-Access"><a href="#Random-Access" class="headerlink" title="Random Access"></a>Random Access</h3><p>随机访问是指高效访问数据集中任何元素的能力。在 Python 中，随机访问通常通过对一个列表进行索引来完成（i.e., <code>data[index]</code>） ，背后实际调用了<code>__getitem__()</code>。PyTorch 使用这种方法来定义映射样式（map-style）的数据集接口（上面实现的那种）。随机访问数据加载器接口还可能要求用户指定数据集的整个长度（<code>__len__()</code>）。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.utils.data</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomAccessDataset</span>(<span class="params">torch.utils.data.Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data: List</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.data)</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index: int): -&gt; Any:</span><br><span class="line">        <span class="keyword">return</span> self.data[index]</span><br></pre></td></tr></tbody></table></figure>
<p>支持随机访问的深度学习数据 api 包括 <code>tfkeras.utils.Sequence</code> 和 <code>torch.utils.data.Dataset</code> (Map Style)。</p>
<h3 id="Sequential-Access"><a href="#Sequential-Access" class="headerlink" title="Sequential Access"></a>Sequential Access</h3><p>顺序读取是一种元素必须按预定顺序访问的模式，通常是通过迭代器访问。在 Python 中，顺序访问通常是通过迭代器和 <code>yield</code> 表达式实现的。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequential_dataset</span>(<span class="params">data: List</span>) -&gt; Iterator:</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></tbody></table></figure>
<p>一些深度学习框架，比如早期版本的 keras，原生支持将数据输入管道（data input pipeline）表示为 Python 生成器。类似地，TensorFlow Datasets 是围绕顺序数据访问构建的。 Python 生成器转换为 TensorFlow Dataset 非常简单，虽然有点啰嗦：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> itertools.count(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> (i, [<span class="number">1</span>] * i)</span><br><span class="line"></span><br><span class="line">dataset = tf.data.Dataset.from_generator(</span><br><span class="line">     gen,</span><br><span class="line">     (tf.int64, tf.int64),</span><br><span class="line">     (tf.TensorShape([]), tf.TensorShape([<span class="literal">None</span>])))</span><br></pre></td></tr></tbody></table></figure>
<p>在下一节中，我们将讨论使用循序访问作为数据加载器的缺点。</p>
<h2 id="Sequential-Access-in-TensorFlow-Datasets"><a href="#Sequential-Access-in-TensorFlow-Datasets" class="headerlink" title="Sequential Access in TensorFlow Datasets"></a>Sequential Access in TensorFlow Datasets</h2><p>TensorFlow 的 <code>tf.data</code> API 以一种优雅的方式简化了数据加载代码的结构：你可以使用 lazy initialization 的方式将一系列操作串起来。<code>tf.data</code> 还提供了 helper API 来完成<a href="https://www.tensorflow.org/api_docs/python/tf/data/Dataset#prefetch">预读取</a>和<a href="https://www.tensorflow.org/guide/data_performance#parallelizing_data_extraction">并行数据加载</a>等常见任务。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dataset = tf.data.Dataset.from_tensor_slices([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> dataset:</span><br><span class="line">   <span class="keyword">print</span> (element)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf.Tensor(<span class="number">1</span>, shape=(), dtype=int32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf.Tensor(<span class="number">2</span>, shape=(), dtype=int32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf.Tensor(<span class="number">3</span>, shape=(), dtype=int32)</span><br><span class="line"></span><br><span class="line">dataset = dataset.map(<span class="keyword">lambda</span> x: x*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> dataset:</span><br><span class="line">   <span class="keyword">print</span> (element)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf.Tensor(<span class="number">2</span>, shape=(), dtype=int32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf.Tensor(<span class="number">4</span>, shape=(), dtype=int32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf.Tensor(<span class="number">6</span>, shape=(), dtype=int32)</span><br></pre></td></tr></tbody></table></figure>
<p>然而，<strong>TensorFlow Dataset 基本上是围绕顺序访问构建的</strong>：<code>tf.data</code> pipeline 中的每一个操作，都会迭代他的输入并生成一个顺序的输出流，供下一个操作使用。这个 API 不支持随机访问，导致在尝试实现一些常见的机器学习工作流时会出现一些重大问题。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dataset[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>TypeError: <span class="string">'TensorSliceDataset'</span> object does <span class="keyword">not</span> support indexing</span><br><span class="line"></span><br><span class="line">list(dataset.as_numpy_iterator())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Data-Shuffling"><a href="#Data-Shuffling" class="headerlink" title="Data Shuffling"></a>Data Shuffling</h3><p>在训练一个深度学习模型时，训练集通常在输入模型前被 shuffle，这个操作通常会提升泛化性能。如果我们的数据 API 只支持顺序访问，要怎样实现 random shuffling 呢？一个简单但是低效的方法是将尽可能多的数据读入内存并在内存里面 shuffle。实际上，这正是 <code>tf.data</code> 的 shuffle 的做法！</p>
<blockquote>
<p>This dataset fills a buffer with <code>buffer_size</code> elements, then randomly samples elements from this buffer, replacing the selected elements with new elements. For perfect shuffling, a buffer size greater than or equal to the full size of the dataset is required.</p>
</blockquote>
<p>对于不能完全放入内存的数据集（深度学习中最常见的情况），<strong><code>shuffle()</code> 实际上不会 shuffle 整个数据集</strong>！这意味着 <code>shuffle()</code> 在大多数应用程序中没有达到预期的效果。包括我们在内的很多从业人员都犯了这个错误，并且看到他们模型的泛化性能因此收到影响。虽然可以通过提前将数据读进内存或 shuffle 文件名列表来实现 shuffle 整个数据集，但是很多用户可能没有意识到这个他们的代码中存在这个问题！</p>
<h3 id="Data-Sharding"><a href="#Data-Sharding" class="headerlink" title="Data Sharding"></a>Data Sharding</h3><p>在进行 data-parallel distributed training 时，每一个 worker（通常是 GPU）要对每个 batch 的一个部分（或者叫 <code>shard</code>）进行训练。为了处理这个常见的任务，<code>tf.data</code> 提供了一个看起来完美契合我们要求的方法：<a href="https://www.tensorflow.org/api_docs/python/tf/data/Dataset#shard"><code>shard(n, i)</code></a>将数据分为 n 个 shards，并返回第 i 个 shard，以便在当前 worker 中继续处理。</p>
<p>不幸的是，这里存在一个陷阱：<code>shard()</code> 会遍历整个输入数据集，每次返回第 n 个记录并忽略其他记录（我的理解是假设 n=4，输入数据会按 12341234 的方式分发，但是每个 worker 都要读完 1234 才能选出第 n 个）！这意味着如果在分布式训练时，对打数据集应用 <code>shard()</code> 操作，每个 worker 在分布式训练任务中最终将读取整个数据集。如果你正在用 64 块 GPU 训练一个模型，这意味着消耗<strong>比预期多 64 倍的磁盘 I/O</strong>。如果你在 <code>shard()</code> 之前进行动态（on-the-fly）数据增强，那么情况会变得更糟 —— 这些数据增强操作会被每个 worker 冗余地执行。</p>
<p>TensorFlow 的文档承认了这一点并指出：</p>
<blockquote>
<p>Generally it is best if the shard operator is used early in the dataset pipeline.<br>通常来说，最好在数据集 pipeline 的早期使用 shard 操作。</p>
</blockquote>
<p>TensorFlow 推荐的方法是创建 TFRecord 文件记录文件名，并在文件名列表上应用 <code>shard()</code>。每个 worker 接收并处理一组不相交的文件，这样就避免了任何不必要的磁盘 I/O。这种方法是有效的，但存在两个问题：</p>
<ol>
<li>在分布式训练中，你要将数据集划分为比 worker 数还要多的文件。如果你有一个大数据集存在少数几个文件中，那你就不走运了。此外，这些文件之间的任何大小不平衡都会导致掉队，从而影响训练效果。</li>
<li>更有可能的是，你没有意识到这些问题！许多实际的数据加载代码只是将 Python 生成器通过 <code>Dataset.from_generator()</code> 转换为 TensorFlow Dataset。当处理小规模数据时，这是没问题的，但是随着数据集的增长，将很快遇到严重的性能问题。</li>
</ol>
<h3 id="保存和还原迭代器状态"><a href="#保存和还原迭代器状态" class="headerlink" title="保存和还原迭代器状态"></a>保存和还原迭代器状态</h3><p>如果你希望构建一个可以从错误中恢复的深度学习训练系统，一种常见的方法是使用 checkpoint-restart：定期将训练任务的状态保存到 checkpoint 文件中，并在发生故障时从最近的 checkpoint 中恢复任务。这对于那些可以持续几个小时甚至几天的训练工作尤其重要。但是，保存和恢复训练需要知道当前训练阶段在数据集中的位置。</p>
<p>例如，如果你在一个 100,000 个元素的数据集上训练，最近的 checkpoint 是在第 50,000 个记录之后执行的，那么你需要确保从第 50,001 条记录恢复，而不是从头开始。对于随机访问接口，这很简单：只需要将索引位置保存为整数，然后从中断的地方恢复训练。对于顺序访问接口，这可能非常困难。总所周知，Python 生成器很难被 pickle（序列化）。TensorFlow Dataset 实验性地支持 checkpoint 和恢复某些类型的数据集，但不支持使用 <code>tf.data.Dataset.from_generator()</code> 创建的数据集。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>之所以存在上述问题，是因为 <code>tf.data</code> 是围绕循序存取构建的。所以，帮自己个忙：不要让你的数据读取代码完全依赖顺序访问模式。如果你像使用预读取和支持顺序读取的函数式风格，你可以像下面这样包装一个随机读取的接口：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dataset = RandomAccessDataset()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequential_access_dataset</span>() -&gt; Iterator:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(len(dataset)):</span><br><span class="line">        <span class="keyword">yield</span> dataset[index]</span><br></pre></td></tr></tbody></table></figure>
<p>从随机到顺序是很容易的，但是走另一条路就难得多了。</p>
<p>TensorFlow Dataset 是目前推荐的在 TensorFlow 中加载数据的方式，而且这种方式看起来一段时间内都不会改变。本文的许多读者可能会发现自己处于一个不幸的位置，由于不可控因素，他们只能依赖 TensorFlow Dataset。如果你也是这样，我们一直在努力寻找一个能让你的生活更轻松的解决方案 —— 下周请继续关注！</p>
]]></content>
      <tags>
        <tag>TensorFlow</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 GitHub Action 自动部署 Hexo 博客</title>
    <url>/2020/08/02/%E4%BD%BF%E7%94%A8GitHub-Action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>基本流程参照 <a href="https://github.com/marketplace/actions/hexo-action">https://github.com/marketplace/actions/hexo-action</a></p>
<h2 id="Step-1-生成ssh-key-pair"><a href="#Step-1-生成ssh-key-pair" class="headerlink" title="Step 1. 生成ssh key pair"></a>Step 1. 生成 ssh key pair</h2><p>首先，我们需要生成 ssh key pair。最好是专门为这个仓库生成一个 pair，因为后面需要上传私钥，如果是本机常用的 ssh key pair，会存在一定风险。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"username@example.com"</span></span><br></pre></td></tr></tbody></table></figure>
<p>邮箱可以修改为自己的邮箱，询问保存 key 的文件路径时，随便写一个，避免覆盖原有的 key。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"> ± ssh-keygen -t rsa -C <span class="string">"username@example.com"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/sundoge/.ssh/id_rsa): hexo</span><br></pre></td></tr></tbody></table></figure>
<p>以输入 <code>hexo</code> 为例，在当前目录下得到 <code>hexo</code>，<code>hexo.pub</code> 两个文件，前者是私钥，后者是公钥。</p>
<p>将公钥填入 <code>Settings &gt; Deploy Keys</code>。将私钥填入 <code>Settings &gt; Secrets</code>，键名设为 <code>DEPLOY_KEY</code>。这样 GitHub Action 就可以利用 <code>DEPLOY_KEY</code> 将生成好的静态页面 push 到部署分支。</p>
<h2 id="Step2-配置GitHub-Action"><a href="#Step2-配置GitHub-Action" class="headerlink" title="Step2: 配置GitHub Action"></a>Step2: 配置 GitHub Action</h2><p>创建<code>.github/workflows/xxx.yml</code>，用你认为的 workflow 名字命名。<a href="https://github.com/marketplace/actions/hexo-action">Hexo Action</a> 里面给出了详细的设置，我这里只放我自己的</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">'dev'</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">A</span> <span class="string">job</span> <span class="string">to</span> <span class="string">deploy</span> <span class="string">blog.</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">node</span> <span class="string">modules</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">cache</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">${{</span> <span class="string">runner.os</span> <span class="string">}}-node-${{</span> <span class="string">hashFiles('**/package-lock.json')</span> <span class="string">}}</span></span><br><span class="line">        <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">${{</span> <span class="string">runner.os</span> <span class="string">}}-node-</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">'true'</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Deploy hexo blog website.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">deploy</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">sma11black/hexo-action@v1.0.2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">deploy_key:</span> <span class="string">${{</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">}}</span></span><br><span class="line">    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">the</span> <span class="string">output</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">"$<span class="template-variable">{{ steps.deploy.outputs.notify }}</span>"</span></span><br></pre></td></tr></tbody></table></figure>
<p>首先我把写作分支设在了 dev，所以触发条件是 dev branch 存在 push 操作。然后我们会检查 <code>node_modules</code> 的缓存，如果没有缓存就 <code>npm install</code> 并缓存。最后我们调用 <code>sma11black/hexo-action</code>，里面本质上就是帮你执行了 <code>hexo deploy</code> 的操作，这样编译好的静态页面就推到 master branch 了。</p>
<p>尝试过几次，删掉多余的 dependency 之后，GitHub Action 正常运作。</p>
<p><img src="https://i.loli.net/2020/07/31/C9HbrLjyUO1X3EQ.png" alt="image.png"></p>
<p>不足的地方在于调用别人的 action，可能有一些需要手动安装的依赖缺失。后续考虑研究一下 GitHub Action。</p>
]]></content>
      <tags>
        <tag>GitHub Action</tag>
      </tags>
  </entry>
</search>
