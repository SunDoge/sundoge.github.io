<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用 Hexo 搭建个人博客</title>
    <url>/2019/09/14/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="安装Node-js和Hexo"><a href="#安装Node-js和Hexo" class="headerlink" title="安装Node.js和Hexo"></a>安装 Node.js 和 Hexo</h2><p>参照 Hexo 官网教程 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvI0luc3RhbGwtTm9kZS1qcw==">https://hexo.io/docs/#Install-Node-js<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</span><br><span class="line">nvm install stable</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></tbody></table></figure>

<h2 id="创建你的博客"><a href="#创建你的博客" class="headerlink" title="创建你的博客"></a>创建你的博客</h2><p>参照 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2V0dXA=">https://hexo.io/docs/setup<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo init sundoge.github.io</span><br></pre></td></tr></tbody></table></figure>

<p>我使用的 <code>hexo-cli</code> 版本为 <code>2.0.0</code> ，会自动拉取默认主题 <code>landscape</code> 。后面将引入<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0"> hexo-theme-next<i class="fa fa-external-link-alt"></i></span> 。</p>
<h2 id="使用Git管理你的博客"><a href="#使用Git管理你的博客" class="headerlink" title="使用Git管理你的博客"></a>使用 Git 管理你的博客</h2><p>Hexo 的设计有个矛盾的地方，theme 有自己的 config 文件，而且不会 merge 到顶层的 config，导致你很难用 git 管理你的 theme。如果你按照 theme-next 的官方文档 install，就相当于在 git 仓库里面创建另 git 仓库，git 是没法管理到仓库里面的仓库的。但是如果单纯使用 git submodule，修改 theme 里面的_config.yml 也是没法用 git 管理的。所以一个折中的方案是，先 fork 一份你要的主题，比如<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N1bkRvZ2UvaGV4by10aGVtZS1uZXh0"> SunDoge/hexo-theme-next<i class="fa fa-external-link-alt"></i></span> ，然后 add submodule</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git submodule add git@github.com:SunDoge/hexo-theme-next.git themes/next</span><br></pre></td></tr></tbody></table></figure>

<p>这样 theme 和博客都能被管理到。如果需要更新 theme，只需要运行</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTgyODMyNC91cGRhdGUtZ2l0LXN1Ym1vZHVsZS10by1sYXRlc3QtY29tbWl0LW9uLW9yaWdpbg==">https://stackoverflow.com/questions/5828324/update-git-submodule-to-latest-commit-on-origin<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git submodule foreach git pull origin master</span><br></pre></td></tr></tbody></table></figure>

<p>这个命令会更新所有的 submodule。</p>
<h2 id="使用theme-next"><a href="#使用theme-next" class="headerlink" title="使用theme-next"></a>使用 theme-next</h2><p>修改顶层<code>_config.yml</code></p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="comment"># theme: landscape</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></tbody></table></figure>

<p>修改 theme 里面的_config.yml</p>
<blockquote>
<p> themes/next/_config.yml</p>
</blockquote>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="开启math支持"><a href="#开启math支持" class="headerlink" title="开启math支持"></a>开启 math 支持</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0L2Jsb2IvbWFzdGVyL2RvY3MvTUFUSC5tZA==">https://github.com/theme-next/hexo-theme-next/blob/master/docs/MATH.md<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Math Formulas Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in Front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line">    <span class="attr">mhchem:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) required for full Katex support.</span></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>

<p>我暂时使用 mathjax，如果实在太慢，后面再换成 katex。这里还需要替换默认的 render。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-pandoc --save # or hexo-renderer-kramed</span><br></pre></td></tr></tbody></table></figure>

<p>这里不用 kramed 的原因是它最后一次更新在 2017 年。还需要安装 pandoc</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pnbS9wYW5kb2MvYmxvYi9tYXN0ZXIvSU5TVEFMTC5tZA==">https://github.com/jgm/pandoc/blob/master/INSTALL.md<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>安装 pandoc 这点让我很不满意，使用 Hexo 已经要安装很多东西了（node_modules），为了 mathjax 还要整个 pandoc。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZGVwbG95bWVudC5odG1sI0dpdA==">https://hexo.io/docs/deployment.html#Git<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">git@github.com:SunDoge/sundoge.github.io.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">published</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后在 github 上新建一个 branch 名为 published</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vZW4vYXJ0aWNsZXMvY3JlYXRpbmctYW5kLWRlbGV0aW5nLWJyYW5jaGVzLXdpdGhpbi15b3VyLXJlcG9zaXRvcnk=">https://help.github.com/en/articles/creating-and-deleting-branches-within-your-repository<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>并把它设为 default branch。然后执行</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></tbody></table></figure>

<p>编译好的文件会被推送到 published 分支。</p>
<h2 id="为什么使用Hexo"><a href="#为什么使用Hexo" class="headerlink" title="为什么使用Hexo"></a>为什么使用 Hexo</h2><p>Hugo 虽然性能好，但是大部分主题年久失修，而且质量都不高，从 jekyll 和 hexo 移植的主题也大多有问题，缺少原有的部分功能。最后没办法，还是要用前端写的工具。</p>
<p>为了方便以后的写作，我计划使用 Rust 开发一个 hexo-cli 的子集，只支持 theme-next 的正确编译🕊🕊🕊​。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Hyper-V 上安装 Manjaro</title>
    <url>/2019/09/15/%E5%9C%A8Hyper-V%E4%B8%8A%E5%AE%89%E8%A3%85manjaro/</url>
    <content><![CDATA[<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS5tYW5qYXJvLm9yZy90L2hvdy10by1ydW4tbWFuamFyby1vbi13aW5kb3dzLTEwLWh5cGVyLXYtZ2VuMi81NDA5Mi8yMA==">https://forum.manjaro.org/t/how-to-run-manjaro-on-windows-10-hyper-v-gen2/54092/20<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><img src="https://i.loli.net/2019/09/15/PFraGJk26T1WjVC.png" alt="xrdp"></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS5tYW5qYXJvLm9yZy90L2luc3RhbGxpbmctbWFuamFyby1pbi1oeXBlci12LXdpdGgtZW5oYW5jZWQtc2Vzc2lvbi1zdXBwb3J0Lzc5Mzk0">https://forum.manjaro.org/t/installing-manjaro-in-hyper-v-with-enhanced-session-support/79394<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>Manjaro</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>写作方向调整</title>
    <url>/2020/07/29/%E5%86%99%E4%BD%9C%E6%96%B9%E5%90%91%E8%B0%83%E6%95%B4/</url>
    <content><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>此次更新了 post 的命名格式。</p>
<h2 id="方向调整"><a href="#方向调整" class="headerlink" title="方向调整"></a>方向调整</h2><p>赵神钦定，这个博客以后只写赵神不会的东西。</p>
]]></content>
      <tags>
        <tag>Announcement</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 theme_config 管理你的 Hexo theme</title>
    <url>/2020/07/31/%E4%BD%BF%E7%94%A8theme-config%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84Hexo-theme/</url>
    <content><![CDATA[<p>自 Hexo 2.8.2 之后<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvY29uZmlndXJhdGlvbg=="> [1]<i class="fa fa-external-link-alt"></i></span>，Hexo 支持使用 <code>theme_config</code> 来配置 theme。在这之前，如果我们想要使用 git 来更新我们 theme，同时又想用 git 管理 theme 的 config，我所知道的唯一一个办法，就是 fork 一份 theme，修改其中的<code>_config.yml</code>，再用 <code>git submodule</code> 将 fork 的 theme 引入博客仓库中。这个过程比较繁琐。</p>
<p>现在，我们可以利用博客仓库下的<code>_config.yml</code> 来覆盖 theme 仓库下的 config。以我使用的 NexT 为例，默认的 Muse scheme 并不和我意，我希望将其修改成 Mist scheme，只需要添加几行配置：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">theme_config:</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">Mist</span></span><br></pre></td></tr></tbody></table></figure>

<p>Hexo 5.0.0 之后<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvY29uZmlndXJhdGlvbg=="> [1]<i class="fa fa-external-link-alt"></i></span>，我们还可以为每个 theme 创建一个单独的 config 文件来进行管理，文件命名规则为<code>_config.[theme].yml</code>。还是以 NexT 为例，创建<code>_config.next.yml</code>，修改内容为：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br></pre></td></tr></tbody></table></figure>

<p>theme 就配置好了。</p>
<p>很奇怪的一点是，目前很多关于 theme 的资料都没有提到 Hexo 已经支持覆盖 theme config，导致我使用了很长一段时间的 Hexo 3.9，却还是在用 fork+submodule 的方法来管理 theme。</p>
<p>下次我将尝试使用 github action 来自动 deploy 我的博客。</p>
<hr>
<p>2020-07-31 Update</p>
<p>Hexo 5.0.0 支持使用 npm 配置 theme 了。以后不需要手动管理版本，只需要</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">npm i hexo-theme-next --save</span><br></pre></td></tr></tbody></table></figure>

<p>目前通过 npm 安装的主题在执行 hexo clean 时会报错，是 Hexo 的已知问题，将在下个版本修复。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow Datasets: The Bad Parts</title>
    <url>/2020/08/02/TensorFlow-Datasets-The-Bad-Parts/</url>
    <content><![CDATA[<p>本文是<span class="exturl" data-url="aHR0cHM6Ly9kZXRlcm1pbmVkLmFpL2Jsb2cvdGYtZGF0YXNldC10aGUtYmFkLXBhcnRzLw=="> https://determined.ai/blog/tf-dataset-the-bad-parts/<i class="fa fa-external-link-alt"></i></span>的译文。我在尝试用 TensorFlow 参照 PyTorch 代码复现一些模型的时候也产生了同样的想法。本文仅供个人研究使用。</p>
<hr>
<p><strong>TLDR</strong>: TensorFlow 的 <code>tf.data</code> API 是一个常用的将数据加载进深度模型的方法。虽然 <code>tf.data</code> 有很多强大的功能，但是它是围绕顺序读取数据集设计的。这个设计导致它无法高效实现一些功能：shuffle 大数据集，分布式训练时对数据进行分片，实现容错训练（fault-tolerant training）。我们认为，在构建深度学习数据读取 API 时，随机访问应该是需要考虑的关键因素。</p>
<p>在构建端到端的企业深度学习平台时，工程团队可能会遇到<span class="exturl" data-url="aHR0cHM6Ly9kZXRlcm1pbmVkLmFpL2Jsb2cvYnVpbGRpbmctYW4tZW50ZXJwcmlzZS1kZWVwLWxlYXJuaW5nLXBsYXRmb3JtLw==">许多陷阱<i class="fa fa-external-link-alt"></i></span>。最常见的问题之一涉及数据加载。训练期间的数据加载常常被忽略，但是它可能对吞吐量产生巨大影响。机器学习框架提供了一些抽象，试图让数据加载变得简单直接。但是，在看似简单接口背后可能隐藏了一些令人惊讶的问题。在这篇文章中，我们将带你了解一个常见的数据加载 API：<span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvYXBpX2RvY3MvcHl0aG9uL3RmL2RhdGEvRGF0YXNldA==">TensorFlow Datasets<i class="fa fa-external-link-alt"></i></span>。</p>
<p><img src="https://i.loli.net/2020/08/02/eKtHoD4mk1CyPsr.png" alt="image.png"></p>
<h2 id="Data-Loader-Patterns"><a href="#Data-Loader-Patterns" class="headerlink" title="Data Loader Patterns"></a>Data Loader Patterns</h2><p>数据加载接口可以使用两种基本模式，<strong>随机访问（random access）</strong>和<strong>顺序访问（sequential access）</strong>。</p>
<h3 id="Random-Access"><a href="#Random-Access" class="headerlink" title="Random Access"></a>Random Access</h3><p>随机访问是指高效访问数据集中任何元素的能力。在 Python 中，随机访问通常通过对一个列表进行索引来完成（i.e., <code>data[index]</code>） ，背后实际调用了<code>__getitem__()</code>。PyTorch 使用这种方法来定义映射样式（map-style）的数据集接口（上面实现的那种）。随机访问数据加载器接口还可能要求用户指定数据集的整个长度（<code>__len__()</code>）。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.utils.data</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomAccessDataset</span>(<span class="params">torch.utils.data.Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data: List</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.data)</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index: int): -&gt; Any:</span><br><span class="line">        <span class="keyword">return</span> self.data[index]</span><br></pre></td></tr></tbody></table></figure>

<p>支持随机访问的深度学习数据 api 包括 <code>tfkeras.utils.Sequence</code> 和 <code>torch.utils.data.Dataset</code> (Map Style)。</p>
<h3 id="Sequential-Access"><a href="#Sequential-Access" class="headerlink" title="Sequential Access"></a>Sequential Access</h3><p>顺序读取是一种元素必须按预定顺序访问的模式，通常是通过迭代器访问。在 Python 中，顺序访问通常是通过迭代器和 <code>yield</code> 表达式实现的。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequential_dataset</span>(<span class="params">data: List</span>) -&gt; Iterator:</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></tbody></table></figure>

<p>一些深度学习框架，比如早期版本的 keras，原生支持将数据输入管道（data input pipeline）表示为 Python 生成器。类似地，TensorFlow Datasets 是围绕顺序数据访问构建的。 Python 生成器转换为 TensorFlow Dataset 非常简单，虽然有点啰嗦：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> itertools.count(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> (i, [<span class="number">1</span>] * i)</span><br><span class="line"></span><br><span class="line">dataset = tf.data.Dataset.from_generator(</span><br><span class="line">     gen,</span><br><span class="line">     (tf.int64, tf.int64),</span><br><span class="line">     (tf.TensorShape([]), tf.TensorShape([<span class="literal">None</span>])))</span><br></pre></td></tr></tbody></table></figure>

<p>在下一节中，我们将讨论使用循序访问作为数据加载器的缺点。</p>
<h2 id="Sequential-Access-in-TensorFlow-Datasets"><a href="#Sequential-Access-in-TensorFlow-Datasets" class="headerlink" title="Sequential Access in TensorFlow Datasets"></a>Sequential Access in TensorFlow Datasets</h2><p>TensorFlow 的 <code>tf.data</code> API 以一种优雅的方式简化了数据加载代码的结构：你可以使用 lazy initialization 的方式将一系列操作串起来。<code>tf.data</code> 还提供了 helper API 来完成<span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvYXBpX2RvY3MvcHl0aG9uL3RmL2RhdGEvRGF0YXNldCNwcmVmZXRjaA==">预读取<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvZ3VpZGUvZGF0YV9wZXJmb3JtYW5jZSNwYXJhbGxlbGl6aW5nX2RhdGFfZXh0cmFjdGlvbg==">并行数据加载<i class="fa fa-external-link-alt"></i></span>等常见任务。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dataset = tf.data.Dataset.from_tensor_slices([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> dataset:</span><br><span class="line">   <span class="keyword">print</span> (element)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf.Tensor(<span class="number">1</span>, shape=(), dtype=int32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf.Tensor(<span class="number">2</span>, shape=(), dtype=int32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf.Tensor(<span class="number">3</span>, shape=(), dtype=int32)</span><br><span class="line"></span><br><span class="line">dataset = dataset.map(<span class="keyword">lambda</span> x: x*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> dataset:</span><br><span class="line">   <span class="keyword">print</span> (element)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf.Tensor(<span class="number">2</span>, shape=(), dtype=int32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf.Tensor(<span class="number">4</span>, shape=(), dtype=int32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf.Tensor(<span class="number">6</span>, shape=(), dtype=int32)</span><br></pre></td></tr></tbody></table></figure>

<p>然而，<strong>TensorFlow Dataset 基本上是围绕顺序访问构建的</strong>：<code>tf.data</code> pipeline 中的每一个操作，都会迭代他的输入并生成一个顺序的输出流，供下一个操作使用。这个 API 不支持随机访问，导致在尝试实现一些常见的机器学习工作流时会出现一些重大问题。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dataset[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>TypeError: <span class="string">'TensorSliceDataset'</span> object does <span class="keyword">not</span> support indexing</span><br><span class="line"></span><br><span class="line">list(dataset.as_numpy_iterator())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Data-Shuffling"><a href="#Data-Shuffling" class="headerlink" title="Data Shuffling"></a>Data Shuffling</h3><p>在训练一个深度学习模型时，训练集通常在输入模型前被 shuffle，这个操作通常会提升泛化性能。如果我们的数据 API 只支持顺序访问，要怎样实现 random shuffling 呢？一个简单但是低效的方法是将尽可能多的数据读入内存并在内存里面 shuffle。实际上，这正是 <code>tf.data</code> 的 shuffle 的做法！</p>
<blockquote>
<p>This dataset fills a buffer with <code>buffer_size</code> elements, then randomly samples elements from this buffer, replacing the selected elements with new elements. For perfect shuffling, a buffer size greater than or equal to the full size of the dataset is required.</p>
</blockquote>
<p>对于不能完全放入内存的数据集（深度学习中最常见的情况），**<code>shuffle()</code> 实际上不会 shuffle 整个数据集 **！这意味着 <code>shuffle()</code> 在大多数应用程序中没有达到预期的效果。包括我们在内的很多从业人员都犯了这个错误，并且看到他们模型的泛化性能因此收到影响。虽然可以通过提前将数据读进内存或 shuffle 文件名列表来实现 shuffle 整个数据集，但是很多用户可能没有意识到这个他们的代码中存在这个问题！</p>
<h3 id="Data-Sharding"><a href="#Data-Sharding" class="headerlink" title="Data Sharding"></a>Data Sharding</h3><p>在进行 data-parallel distributed training 时，每一个 worker（通常是 GPU）要对每个 batch 的一个部分（或者叫 <code>shard</code>）进行训练。为了处理这个常见的任务，<code>tf.data</code> 提供了一个看起来完美契合我们要求的方法：<a href="https://www.tensorflow.org/api_docs/python/tf/data/Dataset#shard"><code>shard(n, i)</code></a>将数据分为 n 个 shards，并返回第 i 个 shard，以便在当前 worker 中继续处理。</p>
<p>不幸的是，这里存在一个陷阱：<code>shard()</code> 会遍历整个输入数据集，每次返回第 n 个记录并忽略其他记录（我的理解是假设 n=4，输入数据会按 12341234 的方式分发，但是每个 worker 都要读完 1234 才能选出第 n 个）！这意味着如果在分布式训练时，对打数据集应用 <code>shard()</code> 操作，每个 worker 在分布式训练任务中最终将读取整个数据集。如果你正在用 64 块 GPU 训练一个模型，这意味着消耗<strong>比预期多 64 倍的磁盘 I/O</strong>。如果你在 <code>shard()</code> 之前进行动态（on-the-fly）数据增强，那么情况会变得更糟 —— 这些数据增强操作会被每个 worker 冗余地执行。</p>
<p>TensorFlow 的文档承认了这一点并指出：</p>
<blockquote>
<p>Generally it is best if the shard operator is used early in the dataset pipeline.<br>通常来说，最好在数据集 pipeline 的早期使用 shard 操作。</p>
</blockquote>
<p>TensorFlow 推荐的方法是创建 TFRecord 文件记录文件名，并在文件名列表上应用 <code>shard()</code>。每个 worker 接收并处理一组不相交的文件，这样就避免了任何不必要的磁盘 I/O。这种方法是有效的，但存在两个问题：</p>
<ol>
<li>在分布式训练中，你要将数据集划分为比 worker 数还要多的文件。如果你有一个大数据集存在少数几个文件中，那你就不走运了。此外，这些文件之间的任何大小不平衡都会导致掉队，从而影响训练效果。</li>
<li>更有可能的是，你没有意识到这些问题！许多实际的数据加载代码只是将 Python 生成器通过 <code>Dataset.from_generator()</code> 转换为 TensorFlow Dataset。当处理小规模数据时，这是没问题的，但是随着数据集的增长，将很快遇到严重的性能问题。</li>
</ol>
<h3 id="保存和还原迭代器状态"><a href="#保存和还原迭代器状态" class="headerlink" title="保存和还原迭代器状态"></a>保存和还原迭代器状态</h3><p>如果你希望构建一个可以从错误中恢复的深度学习训练系统，一种常见的方法是使用 checkpoint-restart：定期将训练任务的状态保存到 checkpoint 文件中，并在发生故障时从最近的 checkpoint 中恢复任务。这对于那些可以持续几个小时甚至几天的训练工作尤其重要。但是，保存和恢复训练需要知道当前训练阶段在数据集中的位置。</p>
<p>例如，如果你在一个 100,000 个元素的数据集上训练，最近的 checkpoint 是在第 50,000 个记录之后执行的，那么你需要确保从第 50,001 条记录恢复，而不是从头开始。对于随机访问接口，这很简单：只需要将索引位置保存为整数，然后从中断的地方恢复训练。对于顺序访问接口，这可能非常困难。总所周知，Python 生成器很难被 pickle（序列化）。TensorFlow Dataset 实验性地支持 checkpoint 和恢复某些类型的数据集，但不支持使用 <code>tf.data.Dataset.from_generator()</code> 创建的数据集。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>之所以存在上述问题，是因为 <code>tf.data</code> 是围绕循序存取构建的。所以，帮自己个忙：不要让你的数据读取代码完全依赖顺序访问模式。如果你像使用预读取和支持顺序读取的函数式风格，你可以像下面这样包装一个随机读取的接口：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dataset = RandomAccessDataset()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequential_access_dataset</span>() -&gt; Iterator:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(len(dataset)):</span><br><span class="line">        <span class="keyword">yield</span> dataset[index]</span><br></pre></td></tr></tbody></table></figure>

<p>从随机到顺序是很容易的，但是走另一条路就难得多了。</p>
<p>TensorFlow Dataset 是目前推荐的在 TensorFlow 中加载数据的方式，而且这种方式看起来一段时间内都不会改变。本文的许多读者可能会发现自己处于一个不幸的位置，由于不可控因素，他们只能依赖 TensorFlow Dataset。如果你也是这样，我们一直在努力寻找一个能让你的生活更轻松的解决方案 —— 下周请继续关注！</p>
]]></content>
      <tags>
        <tag>TensorFlow</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 GitHub Action 自动部署 Hexo 博客</title>
    <url>/2020/08/02/%E4%BD%BF%E7%94%A8GitHub-Action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>基本流程参照<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hcmtldHBsYWNlL2FjdGlvbnMvaGV4by1hY3Rpb24="> https://github.com/marketplace/actions/hexo-action<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="Step-1-生成ssh-key-pair"><a href="#Step-1-生成ssh-key-pair" class="headerlink" title="Step 1. 生成ssh key pair"></a>Step 1. 生成 ssh key pair</h2><p>首先，我们需要生成 ssh key pair。最好是专门为这个仓库生成一个 pair，因为后面需要上传私钥，如果是本机常用的 ssh key pair，会存在一定风险。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"username@example.com"</span></span><br></pre></td></tr></tbody></table></figure>

<p>邮箱可以修改为自己的邮箱，询问保存 key 的文件路径时，随便写一个，避免覆盖原有的 key。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"> ± ssh-keygen -t rsa -C <span class="string">"username@example.com"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/sundoge/.ssh/id_rsa): hexo</span><br></pre></td></tr></tbody></table></figure>

<p>以输入 <code>hexo</code> 为例，在当前目录下得到 <code>hexo</code>，<code>hexo.pub</code> 两个文件，前者是私钥，后者是公钥。</p>
<p>将公钥填入 <code>Settings &gt; Deploy Keys</code>。将私钥填入 <code>Settings &gt; Secrets</code>，键名设为 <code>DEPLOY_KEY</code>。这样 GitHub Action 就可以利用 <code>DEPLOY_KEY</code> 将生成好的静态页面 push 到部署分支。</p>
<h2 id="Step2-配置GitHub-Action"><a href="#Step2-配置GitHub-Action" class="headerlink" title="Step2: 配置GitHub Action"></a>Step2: 配置 GitHub Action</h2><p>创建<code>.github/workflows/xxx.yml</code>，用你认为的 workflow 名字命名。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hcmtldHBsYWNlL2FjdGlvbnMvaGV4by1hY3Rpb24=">Hexo Action<i class="fa fa-external-link-alt"></i></span>里面给出了详细的设置，我这里只放我自己的</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">'dev'</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">A</span> <span class="string">job</span> <span class="string">to</span> <span class="string">deploy</span> <span class="string">blog.</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">node</span> <span class="string">modules</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">cache</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">${{</span> <span class="string">runner.os</span> <span class="string">}}-node-${{</span> <span class="string">hashFiles('**/package-lock.json')</span> <span class="string">}}</span></span><br><span class="line">        <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">${{</span> <span class="string">runner.os</span> <span class="string">}}-node-</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">'true'</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Deploy hexo blog website.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">deploy</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">sma11black/hexo-action@v1.0.2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">deploy_key:</span> <span class="string">${{</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">}}</span></span><br><span class="line">    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">the</span> <span class="string">output</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">"$<span class="template-variable">{{ steps.deploy.outputs.notify }}</span>"</span></span><br></pre></td></tr></tbody></table></figure>

<p>首先我把写作分支设在了 dev，所以触发条件是 dev branch 存在 push 操作。然后我们会检查 <code>node_modules</code> 的缓存，如果没有缓存就 <code>npm install</code> 并缓存。最后我们调用 <code>sma11black/hexo-action</code>，里面本质上就是帮你执行了 <code>hexo deploy</code> 的操作，这样编译好的静态页面就推到 master branch 了。</p>
<p>尝试过几次，删掉多余的 dependency 之后，GitHub Action 正常运作。</p>
<p><img src="https://i.loli.net/2020/07/31/C9HbrLjyUO1X3EQ.png" alt="image.png"></p>
<p>不足的地方在于调用别人的 action，可能有一些需要手动安装的依赖缺失。后续考虑研究一下 GitHub Action。</p>
]]></content>
      <tags>
        <tag>GitHub Action</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 shallow update not allowed 的问题</title>
    <url>/2020/08/04/%E8%A7%A3%E5%86%B3shallow-update-not-allowed%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天 push 代码的时候遇到一个问题：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Counting objects: 47, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (44/44), done.</span><br><span class="line">Writing objects: 100% (47/47), 573.15 KiB | 0 bytes/s, done.</span><br><span class="line">Total 47 (delta 11), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (11/11), done.</span><br><span class="line">To github.com:SunDoge/xxxx.git</span><br><span class="line"> ! [remote rejected] master -&gt; master (shallow update not allowed)</span><br><span class="line">error: failed to push some refs to 'git@github.com:SunDoge/xxxx.git'</span><br></pre></td></tr></tbody></table></figure>

<p>找到 stackoverflow 上的一个答案</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjg5ODM4NDIvcmVtb3RlLXJlamVjdGVkLXNoYWxsb3ctdXBkYXRlLW5vdC1hbGxvd2VkLWFmdGVyLWNoYW5naW5nLWdpdC1yZW1vdGUtdXJs">https://stackoverflow.com/questions/28983842/remote-rejected-shallow-update-not-allowed-after-changing-git-remote-url<i class="fa fa-external-link-alt"></i></span></p>
<p>那么问题也就很明显了，我在 clone 原仓库时用了 <code>git clone --depth 1</code>，导致本地为 shallow repo。解决方法也很简单</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git fetch --unshallow origin</span><br></pre></td></tr></tbody></table></figure>

<p><code>origin</code> 就是原仓库。fetch 完就能正常 push 了。</p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Manjaro 主机插耳机没声音</title>
    <url>/2020/08/05/Manjaro%E4%B8%BB%E6%9C%BA%E6%8F%92%E8%80%B3%E6%9C%BA%E6%B2%A1%E5%A3%B0%E9%9F%B3/</url>
    <content><![CDATA[<h2 id="安装PulseAudio-Volumne-Control"><a href="#安装PulseAudio-Volumne-Control" class="headerlink" title="安装PulseAudio Volumne Control"></a>安装 <code>PulseAudio Volumne Control</code></h2><p>有些主机插入耳机之后没有声音，因为系统自带的音量控制无法检测到前面板。可以安装 <code>PulseAudio Volumne Control</code> 来解决这个问题。</p>
<p>在 <code>Pacman</code> 包管理器中，这个包名叫 <code>pavucontrol</code>（gtk 版本）或 <code>pavucontrol-qt</code>（qt 版本）。安装其中一个即可。</p>
<p><img src="https://i.loli.net/2020/08/06/dZUe7u9h14cQrMl.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/08/06/zqskrioFbcMm7DB.png" alt="image.png"></p>
<h2 id="保存Profile"><a href="#保存Profile" class="headerlink" title="保存Profile"></a>保存 Profile</h2><p>就算解决了耳机没声音的问题，重启之后配置也会丢失，下次开机还要重新配置一边。可以通过命令行将当前的 profile 保存下来，重启之后也不会丢失。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy80NjI2NzAvc2V0LWRlZmF1bHQtcHJvZmlsZS1mb3ItcHVsc2VhdWRpbw==">https://unix.stackexchange.com/questions/462670/set-default-profile-for-pulseaudio<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>先确定当前 profile 的名字</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">pacmd list-cards | grep <span class="string">'active profile'</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后在 <code>/etc/pulse/default.pa</code> 中加一行</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">set-card-profile &lt;cardindex&gt; &lt;profilename&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>我的是</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">set-card-profile 0 output:analog-stereo</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <tags>
        <tag>Manjaro</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>TypedArgs v0.4.0 released!</title>
    <url>/2020/08/08/TypedArgs-v0-4-0-released/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N1bkRvZ2UvdHlwZWQtYXJncw==">TypedArgs<i class="fa fa-external-link-alt"></i></span> v0.4.0 发布了。大部分接口与 v0.3.x 没有差别，但是少了一个 attribute，所以必须升一个 minor version。这篇博客主要记录我的几个设计失误。</p>
<h2 id="argparse-ArgumentParser不能被pickle"><a href="#argparse-ArgumentParser不能被pickle" class="headerlink" title="argparse.ArgumentParser不能被pickle"></a><code>argparse.ArgumentParser</code> 不能被 pickle</h2><p>TypedArgs 内部是使用 Python 标准库 <code>argparse</code> 实现的。一个标准的 <code>argparse</code> 使用流程如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'data'</span>, help=<span class="string">'path to data'</span>)</span><br><span class="line">args = parser.parse_args([<span class="string">'data-path'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> args.data == <span class="string">'data-path'</span></span><br></pre></td></tr></tbody></table></figure>

<p>首先，<code>ArgumentParser</code> 支持指定显示的 program 名，那<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N1bkRvZ2UvdHlwZWQtYXJncw=="> TypedArgs<i class="fa fa-external-link-alt"></i></span>也应该支持。那一个很自然的想法就是让 parser 成为 <code>class TypedArgs</code> 的一个 attribute，这样解析 arguments 的时候就能自由访问。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"><span class="keyword">from</span> typed_args <span class="keyword">import</span> TypedArgs</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Args</span>(<span class="params">TypedArgs</span>):</span></span><br><span class="line">    parser: field(default_factory=<span class="keyword">lambda</span>: argparse.ArgumentParser(prog=<span class="string">'PROG'</span>))</span><br></pre></td></tr></tbody></table></figure>

<p>但是这带来了一个问题，我并没有意识到 <code>ArgumentParser</code> 是不能被 pickle（序列化）的。虽然平时使用没有问题，但是到了多进程环境（比如 PyTorch 的 <code>DistributedDataParallel</code>）就会报错。为此。v0.3.x 临时打了一个 patch，在解析完 arguements 之后，将 <code>self.parser = None</code>。其实这个时候已经造成了 API 变动，minor version 应该 + 1，但是当时思想出了问题，只升了 patch version。当然，没有人会访问 parser，所以理论上问题不大。</p>
<p>v0.4.0 从根本上解决了这个问题，parser 只在解析 arguments 被生成，解析完就回收，不再作为 <code>TypedArgs</code> 上的一个 attribute。</p>
<h2 id="如何让IDE正确识别出类型"><a href="#如何让IDE正确识别出类型" class="headerlink" title="如何让IDE正确识别出类型"></a>如何让 IDE 正确识别出类型</h2><p>PyCharm 和 VS Code 对于类型推倒总是有不同的想法。PyCharm 认为 <code>=</code> 后面的才是正确类型，直接忽略了我的 annotation。VS Code 就蠢一点，认为我的 annotation 是对的，但是使用的时候又自作聪明不显示我标注的类型。最后我采用了现在的方案：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">foo: str = func()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>() -&gt; Any:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>

<p>这样写，两个 IDE 都能正确推导类型，而且也比较符合常识。</p>
<h2 id="使用GitHub-Action自动发布到pypi-org"><a href="#使用GitHub-Action自动发布到pypi-org" class="headerlink" title="使用GitHub Action自动发布到pypi.org"></a>使用 GitHub Action 自动发布到<span class="exturl" data-url="aHR0cHM6Ly9weXBpLm9yZy8="> pypi.org<i class="fa fa-external-link-alt"></i></span></h2><p>GitHub 很贴心，GitHub 整个模板都给你弄好了，你只需要去 <code>Settings &gt; Secrets</code> 填两个参数（<code>PYPI_USERNAME</code> 和 <code>PYPI_PASSWORD</code>）。之后每次 push 带 tag，或者在 GitHub 上创建 release 的时候（创建 release 会创建一个 tag），就会触发这个 GitHub Action，将这个库发布到<span class="exturl" data-url="aHR0cHM6Ly9weXBpLm9yZy8="> pypi.org<i class="fa fa-external-link-alt"></i></span>。</p>
]]></content>
      <tags>
        <tag>Announcement</tag>
        <tag>GitHub Action</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>aria2 无法下载 Amazon S3 的文件</title>
    <url>/2020/09/03/aria2%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BDAmazon-S3%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>今天用<span class="exturl" data-url="aHR0cHM6Ly9hcmlhMi5naXRodWIuaW8v"> aria2<i class="fa fa-external-link-alt"></i></span>下载 <code>s3</code> 上的文件时，出现以下错误：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">09/03 15:34:47 [ERROR] CUID#7 - Download aborted. URI=https://s3.eu-central-1.amazonaws.com/avg-kitti/data_object_image_2.zip</span><br><span class="line">Exception: [AbstractCommand.cc:351] errorCode=1 URI=https://s3.eu-central-1.amazonaws.com/avg-kitti/data_object_image_2.zip</span><br><span class="line">  -&gt; [SocketCore.cc:1018] errorCode=1 SSL/TLS handshake failure: The TLS connection was non-properly terminated.</span><br></pre></td></tr></tbody></table></figure>

<p>但是用 <code>wget</code> 却一切正常。开始怀疑 <code>s3</code> 限制连接数，但是减少线程数仍然无法下载。最后在一个不相关的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FyaWEyL2FyaWEyL2lzc3Vlcy81MDI="> issue #502<i class="fa fa-external-link-alt"></i></span>里面找到了解决办法。似乎问题是 <code>Async DNS</code> 引起的。加上 <code>--async-dns=false</code> 后问题解决。</p>
<p>暂时不清楚 <code>Async DNS</code> 干了什么，如果以后看源码弄清楚了再补充。</p>
]]></content>
      <tags>
        <tag>aria2</tag>
        <tag>Amazon S3</tag>
      </tags>
  </entry>
  <entry>
    <title>在 caption 中 cite 文章报错</title>
    <url>/2020/09/06/%E5%9C%A8caption%E4%B8%ADcite%E6%96%87%E7%AB%A0%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>今天修改论文的时候 Latex 报了一个挺离谱的 bug</p>
<p><img src="https://i.loli.net/2020/09/06/t549w6mfIFNzOsY.png" alt="image.png"></p>
<p>为了方便搜索，下面是文字版</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Undefined control sequence.</span><br><span class="line"></span><br><span class="line">The compiler is having trouble understanding a command you have used. Check that the command is spelled correctly. If the command is part of a package, make sure you have included the package in your preamble using \usepackage{...}.</span><br><span class="line"> Learn more</span><br><span class="line"></span><br><span class="line">\citeauthoryear #1#2-&gt;\def \@thisauthor </span><br><span class="line">                                        {#1}\ifx \@lastauthor \@thisauthor \...</span><br><span class="line">l.172 		}</span><br><span class="line">         </span><br><span class="line">The control sequence at the end of the top line</span><br><span class="line">of your error message was never \def'ed. If you have</span><br><span class="line">misspelled it (e.g., `\hobx'), type `I' and the correct</span><br><span class="line">spelling (e.g., `I\hbox'). Otherwise just continue,</span><br><span class="line">and I'll forget about whatever was undefined.</span><br><span class="line"> self-supervised, line 172</span><br><span class="line"></span><br><span class="line">Illegal parameter number in definition of \reserved@a.</span><br><span class="line"></span><br><span class="line">&lt;to be read again&gt; </span><br><span class="line">                   }</span><br><span class="line">l.172 		}</span><br><span class="line">         </span><br><span class="line">You meant to type ## instead of #, right?</span><br><span class="line">Or maybe a } was forgotten somewhere earlier, and things</span><br><span class="line">are all screwed up? I'm going to assume that you meant ##.</span><br><span class="line"> self-supervised, line 172</span><br><span class="line"></span><br><span class="line">Illegal parameter number in definition of \reserved@a.</span><br><span class="line"></span><br><span class="line">&lt;to be read again&gt; </span><br><span class="line">                    </span><br><span class="line">l.172 		}</span><br><span class="line">         </span><br><span class="line">You meant to type ## instead of #, right?</span><br><span class="line">Or maybe a } was forgotten somewhere earlier, and things</span><br><span class="line">are all screwed up? I'm going to assume that you meant ##.</span><br><span class="line"> self-supervised, line 172</span><br><span class="line"></span><br><span class="line">Illegal parameter number in definition of \reserved@a.</span><br><span class="line"></span><br><span class="line">&lt;to be read again&gt; </span><br><span class="line">                   2</span><br><span class="line">l.172 		}</span><br><span class="line">         </span><br><span class="line">You meant to type ## instead of #, right?</span><br><span class="line">Or maybe a } was forgotten somewhere earlier, and things</span><br><span class="line">are all screwed up? I'm going to assume that you meant ##.</span><br><span class="line"> self-supervised, line 172</span><br><span class="line"></span><br><span class="line">Undefined control sequence.</span><br><span class="line"></span><br><span class="line">The compiler is having trouble understanding a command you have used. Check that the command is spelled correctly. If the command is part of a package, make sure you have included the package in your preamble using \usepackage{...}.</span><br><span class="line"> Learn more</span><br><span class="line"></span><br><span class="line">\cite ...\citeauthoryear ##1##2{\def \@thisauthor </span><br><span class="line">                                                  {##1}\ifx \@lastauthor \@t...</span><br><span class="line">l.172 		}</span><br><span class="line">         </span><br><span class="line">The control sequence at the end of the top line</span><br><span class="line">of your error message was never \def'ed. If you have</span><br><span class="line">misspelled it (e.g., `\hobx'), type `I' and the correct</span><br><span class="line">spelling (e.g., `I\hbox'). Otherwise just continue,</span><br><span class="line">and I'll forget about whatever was undefined.</span><br><span class="line"> self-supervised, line 172</span><br><span class="line"></span><br><span class="line">Illegal parameter number in definition of \reserved@a.</span><br><span class="line"></span><br><span class="line">&lt;to be read again&gt; </span><br><span class="line">                   1</span><br><span class="line">l.172 		}</span><br><span class="line">         </span><br><span class="line">You meant to type ## instead of #, right?</span><br><span class="line">Or maybe a } was forgotten somewhere earlier, and things</span><br><span class="line">are all screwed up? I'm going to assume that you meant ##.</span><br><span class="line"> self-supervised, line 172</span><br><span class="line"></span><br><span class="line">Argument of \caption@ydblarg has an extra }.</span><br><span class="line"></span><br><span class="line">&lt;inserted text&gt; </span><br><span class="line">                \par </span><br><span class="line">l.172 		}</span><br><span class="line">         </span><br><span class="line">I've run across a `}' that doesn't seem to match anything.</span><br><span class="line">For example, `\def\a#1{...}' and `\a}' would produce</span><br><span class="line">this error. If you simply proceed now, the `\par' that</span><br><span class="line">I've just inserted will cause me to report a runaway</span><br><span class="line">argument that might be the root of the problem. But if</span><br><span class="line">your `}' was spurious, just type `2' and it will go away.</span><br><span class="line"> self-supervised, line 172</span><br><span class="line"></span><br><span class="line">Runaway argument?</span><br><span class="line"></span><br><span class="line">{\@caption \@captype }{\@tempswatrue \@citex }\def \reserved@b {\@tempswafalse \ETC.</span><br><span class="line">! Paragraph ended before \caption@ydblarg was complete.</span><br><span class="line">&lt;to be read again&gt; </span><br><span class="line">                   \par </span><br><span class="line">l.172 		}</span><br><span class="line">         </span><br><span class="line">I suspect you've forgotten a `}', causing me to apply this</span><br><span class="line">control sequence to too much text. How can we recover?</span><br><span class="line">My plan is to forget the whole thing and hope for the best.</span><br></pre></td></tr></tbody></table></figure>

<p>从 log 里面基本是没法定位问题，但是通过排除法，最终把问题定位到 <code>~\cite{speednet}</code> 上。我先检查了 bibtex，没有发现问题，随后我意识到可能是 <code>\cite</code> 在 <code>\caption</code> 里面，所以才有 <code>Illegal parameter number</code> 的问题。上网搜了以下，找到以下信息：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzIyNzgzMy9jaXRlLXJlZmVyZW5jZXMtaW4tZmlndXJlLWNhcHRpb24=">https://tex.stackexchange.com/questions/227833/cite-references-in-figure-caption<i class="fa fa-external-link-alt"></i></span></p>
<p>答案作者的解释是 cite 会变成 caption 的 argument，解决方案是加上 <code>\protect</code>。也就是说变成 <code>~\protect\cite{speednet}</code>，问题解决。</p>
]]></content>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中如何设计用户友好的 decorator</title>
    <url>/2020/10/24/Python%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%94%A8%E6%88%B7%E5%8F%8B%E5%A5%BD%E7%9A%84decorator/</url>
    <content><![CDATA[<p>这篇文章假定读者对 python 中的装饰器有一定的了解。</p>
<p>我们先来设计一个最简单的 decorator：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">func</span>):</span></span><br><span class="line">    print(<span class="string">'f1'</span>)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@f1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f0</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="string">'x:'</span>, x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    f0(<span class="string">'asdf'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>当我们执行这个脚本的时候，我们很自然会得到下面的输出</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">f1</span><br><span class="line">x: asdf</span><br></pre></td></tr></tbody></table></figure>

<p>这个时候，我们只能写 <code>@f1</code>，而不能写 <code>@f1()</code>。如果我们把 <code>@f1</code> 改成 <code>@f1()</code>，会得到以下错误：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">TypeError: f1() missing 1 required positional argument: 'func'</span><br></pre></td></tr></tbody></table></figure>

<p>因为被装饰的函数会被当成第一个参数（positional argument），而加上括号之后，相当于少了第一个参数。对于使用者来说，要记忆某个 decorator 是否要带括号是个不小的心智负担。你可能会想，在使用 python 标准库中的 dataclasses 时，<code>@dataclass</code> 和 <code>@dataclass()</code> 都是合法的，为什么这里就不行了。其实想实现 dataclasses 类似的功能其实也很简单。我们只要判断 func 是否为 None，如果是，就返回一个新的 decorator。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">func=None</span>):</span></span><br><span class="line">    print(<span class="string">'f1'</span>)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">func=None</span>):</span></span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> f1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> f1(func=func)</span><br><span class="line"></span><br><span class="line"><span class="meta">@f2()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f0</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="string">'x:'</span>, x)</span><br></pre></td></tr></tbody></table></figure>

<p>这样一切都正常了。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
